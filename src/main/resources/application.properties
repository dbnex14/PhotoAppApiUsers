# port where this app will run, 0 means a random port will be assigned.  We could hardcode port to say 8080 but then
# as we start new instances of microservices, so we will need to track which port were used by which microservices
# and open app.prop file and to each instance assign a port number.  So, having it automaticall assigned is convenient.
# Below, we set port number to PORT which will be assigned if we passed it as command line arg, but if not, it will be
# 0 which means it will be randomly generated for us
server.port=${PORT:0}
# name this app will be known in eureka dashboard
spring.application.name=user-ws
# fully qualified url by which our Eureka client will communicate with Eureka server.  Port 8010 is what we specified
# in Eureka server
eureka.client.service-url.defaultZone=http://localhost:8010/eureka
# We added devtools to have our app automatically restart and redeploy when we change java code.  Sometimes, we can
# disable this by setting to 'false'.
spring.devtools.restart.enabled=true
# if we start more instances, they may simply overwrite already registered instance in the Eureka dashboard therefore
# appearing as single instance is running although we have 2 instances of same microservice up and running (you can see
# that in output console).  this is because when we start multiple instances, application.name will still be the
# same.
# To avoid that we add below property so that each instance gets unique instance id which will identify the running
# instance of microservice.  We create it by combining application.name, and application.instance_id which we can pass
# as agument from command line or have it randomly generated for us.  By the way, we can do same with the port #.
eureka.instance.instance-id=${spring.application.name}:${spring.application.instance_id:${random.value}}